/// <reference types="node" />
export interface MqExchangeMessage {
    exchangeName: string;
    routingKey: string;
    content: Buffer | string;
}
export interface MqTaskMessage {
    queueName: string;
    content: Buffer | string;
}
export interface ConsumerConfig {
    exchangeName: string;
    exchangeType: string;
    queueName: string;
    consumerCallback: (x: any) => (y: any) => void;
}
/**
 * @class
 * @name RabbitMqInterface
 * @description
 *  This class provides us a number of methods for dealing with connecting to
 *  amqplib and allows us to publish and send events to rabbit mq and digest
 *  those events
 * */
export declare class RabbitMqInterface {
    debug: boolean;
    connectionUri: string;
    private offlineQueue;
    constructor();
    /**
     * @method
     * @name setRabbitUri
     * @description
     *  description here
     * */
    setRabbitUri(uri: string): this;
    /**
     * @method
     * @name endableDebugging
     * @description
     *  if this is called we will see debugging statements.
     * */
    enableDebugging(): this;
    /**
     * @method
     * @name disableDebugging
     * @description
     *  if this is called we will not debugging statements.
     * */
    disableDebugging(): this;
    /**
     * @method
     * @description
     * this method is called once upon start up
     * and the recursively anytime we have an error
     * */
    startRabbit(): Promise<any>;
    /**
     * @method
     * @name publishToExchange
     * @description
     *  This will publish our item to an exchange
     * @param {Object} messageConfig - the configuration of the message to be sent
     * @param {String} exchangeType - this is the type e.g. direct, fanout, topic
     * @param {Object} configs - a user can configure the exchanges and stuff whichever way they want
     * */
    publishToExchange({ exchangeName, routingKey, content }: {
        exchangeName: any;
        routingKey: any;
        content: any;
    }, exchangeType: string, configs?: any): Promise<any>;
    sendDirect(messageConfig: MqExchangeMessage, configs?: any): this;
    sendFanout(messageConfig: MqExchangeMessage, configs?: any): this;
    sendTopic(messageConfig: MqExchangeMessage, configs?: any): this;
    sendPublishMessage(channel: any, configs: any, exchangeName: any, routingKey: any, content: any, exchangeType: any): Promise<void>;
    publisherCallback(exchangeName: any, routingKey: any, formattedContent: any, exchangeType: any): (err: any) => void;
    afterPublish(channel: any, conn: any): void;
    handlePublishError(err: any, exchangeName: any, routingKey: any, formattedContent: any, exchangeType: any): void;
    /**
     * @method
     * @name startConsumer
     * @description
     *  This will allow us to consume various sorts of queues, it MUST take a
     *  consumer call back param
     *  @param {Object} queueConfig - a user can configure their consumers
     *  @param {Object} configs - a user can configure the queue
     *  @param {Array} topics - a list of topics for a topic exchange
     * */
    startConsumer({ exchangeName, exchangeType, queueName, consumerCallback, }: {
        exchangeName?: string;
        exchangeType?: string;
        queueName?: string;
        consumerCallback: any;
    }, configs?: any, topics?: string[]): Promise<any>;
    /**
     * @method
     * @name mapTopics
     * @description
     *  If we have topics well need to map them and await the promise
     * */
    mapTopics(channel: any, queue: any, exchangeName: string, topics: string[]): Promise<any>;
    /**
     * @method
     * @name startDirectConsumer
     * @description
     *  this will allow us to start a direct consumer
     * @param {Object} consumerConfig - this is the config for our exchange name and other fields
     * */
    startDirectConsumer(consumerConfig: ConsumerConfig, configs?: any): this;
    /**
     * @method
     * @name startFanoutConsumer
     * @description
     *  this will allow us to start a fanout consumer
     * @param {Object} consumerConfig - this is the config for our exchange name and other fields
     * */
    startFanoutConsumer(consumerConfig: ConsumerConfig, configs?: any): this;
    /**
     * @method
     * @name startTopicConsumer
     * @description
     *  this will allow us to start a topic consumer
     * @param {Object} consumerConfig - this is the config for our exchange name and other fields
     * @param {Array} topics - this is a list of topics we want the queue to listen for
     * */
    startTopicConsumer(consumerConfig: ConsumerConfig, topics: string[], configs?: any): this;
    /**
     * @method
     * @name bufferIfy
     * @description
     *  This will turn our content into a buffer
     * @param {Object | String} content - the content we want to turn into a buffer
     * */
    bufferIfy(content: any): Buffer;
    /**
     * @method
     * @name handleRabbitErrror
     * @description
     *  This will handleRabbitErrror
     * */
    handleRabbitErrror(err: any): void;
    /**
     * @method
     * @name handleRabbitClose
     * @description
     *  This will handleRabbitClose
     * */
    handleRabbitClose(): void;
    /**
     * @method
     * @name isJsonString
     * @description
     *  This will check to see if a value contains a valid json string
     * */
    isJsonString(str: any): boolean;
    /**
     * @method
     * @description
     *  This will decode our buffer into an object, array, whatever it is.
     * */
    decodeToString(message: any): string;
    /**
     * @method
     * @description
     *  This will decode our buffer into an object, array, whatever it is.
     * */
    decodeToJson(message: any): any;
    /**
     * @method
     * @name logger
     * @description
     *  This will either log or not log messages depending
     *  on a debug flag set by users
     * */
    logger(message: string, level?: string): void;
}
